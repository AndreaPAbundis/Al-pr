<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Andrea Palma</title>
  <link rel="icon" type="image/png" href="https://dummyimage.com/64x64/000/fff" sizes="64x64">
  <link rel="icon" type="image/png" href="https://dummyimage.com/180x180/000/fff" sizes="180x180">
  <!-- [#TODO] Dont forget to update the FAVICON IMAGES in the next route -->
  <!-- <link rel="icon" type="image/png" href="assets/images/favicon-180x180.png" sizes="128x128"> -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" integrity="sha256-K3Njjl2oe0gjRteXwX01fQD5fkk9JFFBdUHy/h38ggY=" crossorigin="anonymous" rel="stylesheet">
  <link href="./assets/styles/main.css" rel="stylesheet">
  <link rel="stylesheet" href="assets/swiper/swiper/dist/css/swiper.min.css">
</head>

<body>
  <!--  Header  -->

  <div class="header-container">
    <header class="main-nav">
      <nav role="navigation" class="navbar">
        <ul>
          <a href="index.html">
            <li class="space-options"><img src="assets/images/logo.png"></li>
          </a>
          <a href="#estructur">
            <li class="space-options">Estructuras |</li>
          </a>
          <a href="#union">
            <li class="space-options">Uniones |</li>
          </a>
          <a href="#metodos">
            <li class="space-options">Metodos de ordenamiento |</li>
          </a>
          <a href="#listas">
            <li class="space-options">Listas enlazadas |</li>
          </a>
        </ul>
      </nav>
    </header>
  </div>
  <!--  Hero -->
<!--Slider-->
  <style>
    html, body {
      position: relative;
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .swiper-container {
      width: 100%;
      height: 60%;
      margin-left: auto;
      margin-right: auto;
      background-color: #48D1CC;
    }
    .swiper-slide {
      text-align: center;
      font-size: 30px;
      background: #48D1CC;
      color: #fff;
      /* Center slide text vertically */
      display: -webkit-box;
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;
      -webkit-box-pack: center;
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
      -webkit-box-align: center;
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
    }
  </style>
</head>
  <!-- Swiper -->
  <div class="swiper-container">
    <div class="swiper-wrapper">
      <div class="swiper-slide">Algoritmos y estructura de datos<br>Parcial 2</div>
      <div class="swiper-slide">Mestra.<br>Emma Fabiola</div>
      <div class="swiper-slide">Andrea Lizbeth Palma Abundis<br>2P2<br>17310232</div>
    </div>
    <!-- Add Pagination -->
    <div class="swiper-pagination"></div>
    <!-- Add Arrows -->
    <div class="swiper-button-next"></div>
    <div class="swiper-button-prev"></div>
  </div>

  <!-- Swiper JS -->
  <script src="assets/swiper/swiper/dist/js/swiper.min.js"></script>

  <!-- Initialize Swiper -->
  <script>
    var swiper = new Swiper('.swiper-container', {
      slidesPerView: 1,
      spaceBetween: 30,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  </script>

  <!--  Main content -->
  <main class="j-workspace ">
    <div class="j-wrap">
      <div class="content">
      <a name="estructur" id="estructur">
        <div class="h">
          <p>as</p>
        </div>
      </a>
        <hr>
        <h1>Estructuras</h1>
        <h2>Definicion</h2>
        <p>Tipo de dato compuesto que puede almacenar distintos tipos de datos</p>
        <h2>Sintaxis</h2>
        <pre class="pre1">
           struct [nombre_estructura] {
           [tipo][miembro1]
           [tipo][miembro2]
           [tipo][miembro3]
           }[NombreVariable];
       </pre>
        <p> <strong>struct</strong>:  es una palabra reservada de C que indica que los elementos que vienen agrupados a continuación entre llaves componen una estructura.<br>
           <strong>nombre_estructura</strong>: identifica el tipo de dato que se describe y del cual se podrán declarar variables. Se especifica entre corchetes para indicar su opcionalidad.<br>
           <strong>miembro1, miembro2,...</strong>: Son los elementos que componen la estructura de datos, deben ser precedidos por el tipo_dato al cual pertenecen.</p>
        <h2>Ejemplo</h2>
          <pre class="pre1">
          struct Persona {
          char Nombre[65];
          char Direccion[65];
          int AnyoNacimiento;
          } Fulanito;
        </pre>
        <h4>Ejemplo de programa</h4>
        <pre>
          #include "stdio.h"
          #include "stdlib.h"

          /* run this program using the console pauser or add your own getch, system("pause") or input loop */
          struct persona{
          	char nom[50];
          	int edad;
          	char sexo;
          } p;
          void capturar(){
          	printf("Ingresa el nombre\n");
          	gets(p.nom);
          	printf("Ingresa la edad\n");
          	scanf("%i", &p.edad);
          	printf("Ingresa el sexo\n");
          	fflush(stdin);
          	scanf("%c", &p.sexo);
          }
          void imprimir(){
          	printf("Nombre: %s\n", p.nom);
          	printf("Edad: %i\n", p.edad);
          	printf("Sexo: %c\n", p.sexo);
          }
          int main(int argc, char *argv[]) {
          	capturar();
          	imprimir();
          	system("PAUSE");
          }
        </pre>
        <hr>
      </div>
      <div class="content" id="union">
        <a name="union" id="union">
          <p style="color:white;">sfdsdf</p>
        </a>
        <h1>Uniones</h1>
        <h2>Definicion</h2>
        Una union es un tipo de datos derivado, como una estructura, con miembros
        que comparten el mismo espacio de almacenamiento.<br>
        Una variable de tipo union puede contener (en momentos diferentes) objetos
        de diferentes tipos y tamaños.<br>
        Las uniones proporcionan una forma de manipular diferentes clases de datos
        dentro de una sola ´area de almacenamiento.<br>
        En cualquier momento una union puede contener un máximo de un objeto
        debido.<br>
        <h2>Sintaxis</h2>
        Una union se declara con el mismo formato de una struct. Primero declaramos
        el tipo union y luego declaramos variables de ese tipo.
        <pre class="pre1">
           union [nombre_de_la_union] {
           [tipo][miembro1]
           [tipo][miembro2]
           [tipo][miembro3]
           }[NombreVariable];
         </pre>
          <h2>Ejemplo</h2>
          <pre class="pre1">
            union Valores{
            int ival;
            float fval;
            float sval;
            };
          </pre>
          <br>
          <h4>Ejemplo de programa</h4>
          <pre class="pre1">
          #include "stdio.h"
          #include "string.h"

          /*Creamos una union*/
          union frases
          {
          	char mensajes[50];
          	char ayudas[50];
          	char lineas[50];
          } palabra;

          /*Creamos una estructura*/
          struct comparte
          {
          	char mensajes[50];
          	char ayudas[50];
          	char lineas[50];
          }Sistema;

          /*Nótese que la estructura y la union tienen los mismos tipos de datos*/

          int main(int argc, char** argv)
          {
          	/*Inicializamos*/
          	strcpy(palabra.mensajes, "Primer Mensaje");

          	/*Inicializamos*/
          	strcpy(palabra.ayudas, "Una Ayuda");

          	printf("\nFrases en Union: ");

          	/*Imprimimos mensajes de union*/
          	printf("\n1- %s", palabra.mensajes);

          	/*Imprimimos ayudas de union*/
          	printf("\n2- %s", palabra.ayudas);

          	/*Inicializamos*/
          	strcpy(Sistema.mensajes, "Primer Mensaje");

          	/*Inicializamos*/
          	strcpy(Sistema.ayudas, "Una Ayuda");

          	/* Podemos notar que aunque inicializamos los valores
          	 * al imprimir se tiene el mismo valor para cada miembro
          	 * de la estructura, esto se debe a que las uniones usan el
          	 * mismo espacio de memoria para todos los elementos
          	 * de la union, siendo del tamaño de su miembro de
          	 * mayor tamaño, en este caso 50 bytes.
          	 * Entonces los tres miembros creados dentro de la
          	 * union comparten esos 50 bytes.
          	 * Entonces el ultimo valor agregado a la union es
          	 * el que se tiene.
          	 */

          	printf("\n\nFrases en Struct: ");

          	/*Imprimimos mensajes de struct*/
          	printf("\n1- %s", Sistema.mensajes);

          	/*Imprimimos ayudas de union*/
          	printf("\n2- %s", Sistema.ayudas);

          	/* En la estructura comparte, se reservan 150 bytes
          	 * de memoria para los tres miembros, en este caso
          	 * cada uno es independiente en memoria, asi pues se
          	 * puede inicializar cada uno o usar como un campo
          	 * independiente.
          	 */

          	return 0;
          }
        </pre>
        <hr>
      </div>
    <div class="content" id="metodos">
      <a name="metodos" id="metodos">
        <p style="color:white;">sfdsdf</p>
      </a>
      <h1>Métodos de ordenamiento.</h1>
      <h2>Burbuja.</h2>
      <p>Es un sencillo algoritmo de ordenamiento. Funciona revisando cada elemento de la lista que va a ser ordenada con el siguiente, intercambiándolos de posición si están en el orden equivocado. Es necesario revisar varias veces toda la lista hasta que no se necesiten más intercambios, lo cual significa que la lista está ordenada. Este algoritmo obtiene su nombre de la forma con la que suben por la lista los elementos durante los intercambios, como si fueran pequeñas "burbujas". También es conocido como el método del intercambio directo. Dado que solo usa comparaciones para operar elementos, se lo considera un algoritmo de comparación, siendo uno de los más sencillo de implementar.
      </p>
      <div class="img"><img src="assets/images/burbuja.gif"></div>
      <h2>Inserción</h2>
      <p>Inicialmente se tiene un solo elemento, que obviamente es un conjunto ordenado. Después, cuando hay k elementos ordenados de menor a mayor, se toma el elemento k+1 y se compara con todos los elementos ya ordenados, deteniéndose cuando se encuentra un elemento menor (todos los elementos mayores han sido desplazados una posición a la derecha) o cuando ya no se encuentran elementos (todos los elementos fueron desplazados y este es el más pequeño). En este punto se inserta el elemento k+1 debiendo desplazarse los demás elementos.
      </p>
      <div class="img"><img src="assets/images/insercion.gif"></div>
      <h2>Selección</h2>
      <p>
        1.Buscar el mínimo elemento de la lista<br>
        2.Intercambiarlo con el primero<b3>
        3.Buscar el siguiente mínimo en el resto de la lista<br>
        4.Intercambiarlo con el segundo<br>
        Y en general:<br>
        -Buscar el mínimo elemento entre una posición i y el final de la lista
        <br>-Intercambiar el mínimo con el elemento de la posición i
      </p>
      <div class="img"><img src="assets/images/seleccion.gif"></div>
      <h2>Shell</h2>
      <p>El algoritmo Shell es una mejora de la ordenación por inserción, donde se van comparando elementos distantes, al tiempo que se los intercambian si corresponde. A medida que se aumentan los pasos, el tamaño de los saltos disminuye; por esto mismo, es útil tanto como si los datos desordenados se encuentran cercanos, o lejanos.
      <br>
      Es bastante adecuado para ordenar listas de tamaño moderado, debido a que su velocidad es aceptable y su codificación es bastante sencilla. Su velocidad depende de la secuencia de valores con los cuales trabaja, ordenándolos.El siguiente ejemplo muestra el proceso de forma gráfica:<br>
      Considerando un valor pequeño que está inicialmente almacenado en el final del vector. Usando un ordenamiento O(n2) como el ordenamiento de burbuja o el ordenamiento por inserción, tomará aproximadamente n comparaciones e intercambios para mover este valor hacia el otro extremo del vector.
      <br>
      El Shell sort primero mueve los valores usando tamaños de espacio gigantes, de manera que un valor pequeño se moverá bastantes posiciones hacia su posición final, con sólo unas pocas comparaciones e intercambios.
      </p>
      <div class="img"><img src="assets/images/shell.jpg"></div>
    </div>
    <div class="content" id="listas">
      <a name="listas" id="listas">
        <p style="color:white;">sfdsdf</p>
      </a>
      <h1>Listas enlazadas</h1>
      <h2>Definicion</h2>
      <p>Una lista enlazada es una de las estructuras de datos fundamentales, y puede ser usada para implementar otras estructuras de datos. Consiste en una secuencia de nodos, en los que se guardan campos de datos arbitrarios y una o dos referencias, enlaces o punteros al nodo anterior o posterior. El principal beneficio de las listas enlazadas respecto a los vectores convencionales es que el orden de los elementos enlazados puede ser diferente al orden de almacenamiento en la memoria o el disco, permitiendo que el orden de recorrido de la lista sea diferente al de almacenamiento.
      </p>
      <h2 style="text-align: center;">Tipos de listas enlazadas</h2>
      <h3>Listas simples enlazadas</h3>
      <p>Es una lista enlazada de nodos, donde cada nodo tiene un único campo de enlace. Una variable de referencia contiene una referencia al primer nodo, cada nodo (excepto el último) enlaza con el nodo siguiente, y el enlace del último nodo contiene NULL para indicar el final de la lista. Aunque normalmente a la variable de referencia se la suele llamar top, se le podría llamar como se desee.
      </p>
      <h3>Listas doblemente enlazadas</h3>
      <p>Un tipo de lista enlazada más sofisticado es la lista doblemente enlazada o lista enlazadas de dos vías. Cada nodo tiene dos enlaces: uno apunta al nodo anterior, o apunta al valor NULL si es el primer nodo; y otro que apunta al nodo siguiente, o apunta al valor NULL si es el último nodo.<br>
      En algún lenguaje de muy bajo nivel, XOR-Linking ofrece una vía para implementar listas doblemente enlazadas, usando una sola palabra para ambos enlaces, aunque esta técnica no se suele utilizar.
      <h3>Listas enlazadas circulares</h3>
      <p>En una lista enlazada circular, el primer y el último nodo están unidos juntos. Esto se puede hacer tanto para listas enlazadas simples como para las doblemente enlazadas. Para recorrer una lista enlazada circular podemos empezar por cualquier nodo y seguir la lista en cualquier dirección hasta que se regrese hasta el nodo original. Desde otro punto de vista, las listas enlazadas circulares pueden ser vistas como listas sin comienzo ni fin. Este tipo de listas es el más usado para dirigir buffers para “ingerir” datos, y para visitar todos los nodos de una lista a partir de uno dado.
      </p>
      <h3>Listas enlazadas simples circulares</h3>
      <p>Cada nodo tiene un enlace, similar al de las listas enlazadas simples, excepto que el siguiente nodo del último apunta al primero. Como en una lista enlazada simple, los nuevos nodos pueden ser solo eficientemente insertados después de uno que ya tengamos referenciado. Por esta razón, es usual quedarse con una referencia solamente al último elemento en una lista enlazada circular simple, esto nos permite rápidas inserciones al principio, y también permite accesos al primer nodo desde el puntero del último nodo.
      </p>
      <h3>Listas enlazadas doblemente circulares</h3>
      <p>En una lista enlazada doblemente circular, cada nodo tiene dos enlaces, similares a los de la lista doblemente enlazada, excepto que el enlace anterior del primer nodo apunta al último y el enlace siguiente del último nodo, apunta al primero. Como en una lista doblemente enlazada, las inserciones y eliminaciones pueden ser hechas desde cualquier punto con acceso a algún nodo cercano. Aunque estructuralmente una lista circular doblemente enlazada no tiene ni principio ni fin, un puntero de acceso externo puede establecer el nodo apuntado que está en la cabeza o al nodo cola, y así mantener el orden tan bien como en una lista doblemente enlazada.
      </p>
  </div>
  </main>
  <footer>
  </footer>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.0/jquery.min.js"></script>
  <script src="assets/scripts/ripple.js"></script>
  <script src="assets/scripts/header.js"></script>

</body>
</html>
